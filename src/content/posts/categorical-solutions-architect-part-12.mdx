---
title: "Monads: Cross-Cutting Concerns That Actually Compose"
description: "Error handling, logging, async operations—these are monads. Part 12 of applying category theory to Solutions Architecture, where we learn why monads solve the composition problem for side effects."
featured: false
pubDate: "2025-12-14T12:00:00.000Z"
language: en
category: "Architecture"
series: "Categorical Solutions Architecture"
seriesOrder: 12
tags: ["Category Theory", "Solutions Architecture", "Monads", "Software Architecture", "AWS"]
draft: true
---

import Lead from '../../components/editorial/Lead.astro';
import InfoBox from '../../components/editorial/InfoBox.astro';

> *"A monad is just a monoid in the category of endofunctors, what's the problem?"*
>
> — **James Iry**, satirizing category theory jargon

<Lead>

Every Solutions Architect deals with cross-cutting concerns: error handling, logging, retries, transactions. The problem isn't implementing them—it's composing them. Monads solve this. They're not abstract mathematics imposed on practical work; they're the structure that makes composition of effectful operations possible.

</Lead>

## The Composition Problem

Pure functions compose beautifully:

```typescript
const f = (x: A): B => /* ... */;
const g = (y: B): C => /* ... */;
const h = g ∘ f;  // Works perfectly
```

But real operations have effects:

```typescript
const f = (x: A): B | Error => /* ... */;  // Can fail
const g = (y: B): C | Error => /* ... */;  // Can also fail

// How do we compose these?
const h = ???  // Need to handle f's error before calling g
```

Monads provide the structure to compose effectful operations.

---

## What Is a Monad?

A **monad** on a category $\mathcal{C}$ consists of:

1. An endofunctor $T: \mathcal{C} \to \mathcal{C}$
2. A natural transformation $\eta: \text{Id} \Rightarrow T$ (unit/return)
3. A natural transformation $\mu: T \circ T \Rightarrow T$ (join/flatten)

Satisfying the monad laws:

$$
\mu \circ T\mu = \mu \circ \mu T \quad \text{(associativity)}
$$
$$
\mu \circ T\eta = \mu \circ \eta T = \text{id}_T \quad \text{(unit laws)}
$$

### In TypeScript

```typescript
interface Monad<T> {
  // Functor part
  map: <A, B>(ta: T<A>, f: (a: A) => B) => T<B>;

  // Unit (return/pure/of)
  unit: <A>(a: A) => T<A>;

  // Join (flatten)
  join: <A>(tta: T<T<A>>) => T<A>;

  // Or equivalently, bind (flatMap)
  bind: <A, B>(ta: T<A>, f: (a: A) => T<B>) => T<B>;
}
```

The key operation is **bind** (also called `flatMap`, `>>=`, `chain`):

```typescript
// bind in terms of join
const bind = <A, B>(ta: T<A>, f: (a: A) => T<B>): T<B> =>
  join(map(ta, f));

// join in terms of bind
const join = <A>(tta: T<T<A>>): T<A> =>
  bind(tta, x => x);
```

---

## The Classic Monads

### Maybe/Option: Handling Absence

```typescript
type Option<A> = { tag: 'Some'; value: A } | { tag: 'None' };

const optionMonad: Monad<Option> = {
  unit: <A>(a: A): Option<A> => ({ tag: 'Some', value: a }),

  bind: <A, B>(oa: Option<A>, f: (a: A) => Option<B>): Option<B> =>
    oa.tag === 'Some' ? f(oa.value) : { tag: 'None' },
};

// Now composition works!
const safeDiv = (a: number, b: number): Option<number> =>
  b === 0 ? { tag: 'None' } : { tag: 'Some', value: a / b };

const computation = optionMonad.bind(
  optionMonad.bind(
    optionMonad.unit(10),
    x => safeDiv(x, 2)
  ),
  y => safeDiv(y, 0)  // This None propagates
);
```

### Result/Either: Handling Errors

```typescript
type Result<E, A> = { tag: 'Ok'; value: A } | { tag: 'Err'; error: E };

const resultMonad = <E>(): Monad<Result<E, *>> => ({
  unit: <A>(a: A): Result<E, A> => ({ tag: 'Ok', value: a }),

  bind: <A, B>(ra: Result<E, A>, f: (a: A) => Result<E, B>): Result<E, B> =>
    ra.tag === 'Ok' ? f(ra.value) : ra,
});

// Compose operations that can fail with specific errors
type DbError = 'NotFound' | 'ConnectionError';

const getUser = (id: string): Result<DbError, User> => /* ... */;
const getOrders = (user: User): Result<DbError, Order[]> => /* ... */;

const getUserOrders = (id: string): Result<DbError, Order[]> =>
  resultMonad<DbError>().bind(getUser(id), getOrders);
```

### Promise/Async: Handling Asynchrony

```typescript
// Promise IS a monad
const promiseMonad: Monad<Promise> = {
  unit: <A>(a: A): Promise<A> => Promise.resolve(a),
  bind: <A, B>(pa: Promise<A>, f: (a: A) => Promise<B>): Promise<B> =>
    pa.then(f),
};

// Async composition
const fetchUser = (id: string): Promise<User> => /* ... */;
const fetchOrders = (user: User): Promise<Order[]> => /* ... */;

const fetchUserOrders = (id: string): Promise<Order[]> =>
  fetchUser(id).then(fetchOrders);  // Monadic bind!
```

---

## Monads in Architecture

### The Request Processing Monad

Every request goes through a pipeline of effects:

```typescript
// The effects we need to compose
type RequestEffect<A> =
  | { tag: 'Success'; value: A }
  | { tag: 'AuthError'; message: string }
  | { tag: 'ValidationError'; errors: string[] }
  | { tag: 'ServiceError'; service: string; error: Error };

const requestMonad: Monad<RequestEffect> = {
  unit: <A>(a: A): RequestEffect<A> => ({ tag: 'Success', value: a }),

  bind: <A, B>(
    ra: RequestEffect<A>,
    f: (a: A) => RequestEffect<B>
  ): RequestEffect<B> =>
    ra.tag === 'Success' ? f(ra.value) : ra,
};

// Now build the pipeline
const processRequest = (req: RawRequest): RequestEffect<Response> =>
  pipe(
    authenticate(req),          // RequestEffect<AuthenticatedRequest>
    bind(validate),             // RequestEffect<ValidRequest>
    bind(authorize),            // RequestEffect<AuthorizedRequest>
    bind(executeBusinessLogic), // RequestEffect<BusinessResult>
    bind(formatResponse)        // RequestEffect<Response>
  );
```

### The Retry Monad

```typescript
interface RetryConfig {
  maxRetries: number;
  backoff: (attempt: number) => number;
}

type Retry<A> = (config: RetryConfig) => Promise<A>;

const retryMonad: Monad<Retry> = {
  unit: <A>(a: A): Retry<A> => (_config) => Promise.resolve(a),

  bind: <A, B>(ra: Retry<A>, f: (a: A) => Retry<B>): Retry<B> =>
    (config) => ra(config).then(a => f(a)(config)),
};

// With retry logic
const withRetry = <A>(operation: () => Promise<A>): Retry<A> =>
  async (config) => {
    for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
      try {
        return await operation();
      } catch (e) {
        if (attempt === config.maxRetries) throw e;
        await delay(config.backoff(attempt));
      }
    }
    throw new Error('Unreachable');
  };
```

### The Transaction Monad

```typescript
type Transaction<A> = (conn: DbConnection) => Promise<A>;

const transactionMonad: Monad<Transaction> = {
  unit: <A>(a: A): Transaction<A> => (_conn) => Promise.resolve(a),

  bind: <A, B>(ta: Transaction<A>, f: (a: A) => Transaction<B>): Transaction<B> =>
    (conn) => ta(conn).then(a => f(a)(conn)),
};

// Run with transaction semantics
const runTransaction = async <A>(
  pool: DbPool,
  tx: Transaction<A>
): Promise<A> => {
  const conn = await pool.getConnection();
  try {
    await conn.query('BEGIN');
    const result = await tx(conn);
    await conn.query('COMMIT');
    return result;
  } catch (e) {
    await conn.query('ROLLBACK');
    throw e;
  } finally {
    conn.release();
  }
};
```

---

## Monad Transformers: Stacking Effects

Real applications have multiple effects simultaneously:

```typescript
// We need: Async + Error + Logging
// Solution: Monad transformers (conceptually)

type AppEffect<A> = {
  run: (logger: Logger) => Promise<Result<AppError, A>>;
};

const appMonad: Monad<AppEffect> = {
  unit: <A>(a: A): AppEffect<A> => ({
    run: (_logger) => Promise.resolve({ tag: 'Ok', value: a })
  }),

  bind: <A, B>(
    ma: AppEffect<A>,
    f: (a: A) => AppEffect<B>
  ): AppEffect<B> => ({
    run: async (logger) => {
      const result = await ma.run(logger);
      if (result.tag === 'Err') return result;
      return f(result.value).run(logger);
    }
  }),
};

// Use the composed effect
const processOrder: AppEffect<Order> =
  pipe(
    validateOrder(input),    // AppEffect<ValidOrder>
    bind(checkInventory),    // AppEffect<InventoryResult>
    bind(processPayment),    // AppEffect<PaymentResult>
    bind(createOrder)        // AppEffect<Order>
  );

// Run with all effects
const result = await processOrder.run(logger);
```

<InfoBox title="Effect Composition" type="tip">

The monad structure ensures that all effects (async, error, logging) compose correctly. Each step can fail, log, and is async—and the composition handles all of it.

</InfoBox>

---

## The Monad Laws in Practice

### Law 1: Left Identity

$\text{bind}(\text{unit}(a), f) = f(a)$

```typescript
// Wrapping and immediately unwrapping does nothing
bind(unit(5), x => unit(x + 1))  // Same as unit(6)
```

**Architectural meaning**: Creating a "pure" value then processing it is the same as just processing the raw value.

### Law 2: Right Identity

$\text{bind}(m, \text{unit}) = m$

```typescript
// Processing then wrapping in identity does nothing
bind(someMonad, unit)  // Same as someMonad
```

**Architectural meaning**: Processing then returning unchanged is the same as not processing.

### Law 3: Associativity

$\text{bind}(\text{bind}(m, f), g) = \text{bind}(m, x \Rightarrow \text{bind}(f(x), g))$

```typescript
// Grouping doesn't matter
bind(bind(m, f), g)  // Same as
bind(m, x => bind(f(x), g))
```

**Architectural meaning**: Processing order is determined by data flow, not by how you group operations. Pipelines associate.

---

## AWS Monads

### Lambda Response Monad

```typescript
type LambdaResult<A> =
  | { statusCode: 200; body: A }
  | { statusCode: 400; error: ValidationError }
  | { statusCode: 500; error: InternalError };

const lambdaMonad: Monad<LambdaResult> = {
  unit: <A>(a: A) => ({ statusCode: 200, body: a }),

  bind: <A, B>(
    ra: LambdaResult<A>,
    f: (a: A) => LambdaResult<B>
  ): LambdaResult<B> =>
    ra.statusCode === 200 ? f(ra.body) : ra,
};
```

### Step Functions as Monad

Step Functions states are monadic:

```json
{
  "StartAt": "Step1",
  "States": {
    "Step1": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:step1",
      "Next": "Step2"
    },
    "Step2": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:step2",
      "Next": "Step3"
    }
  }
}
```

Each state transform is a monadic operation. The sequencing is `bind`. Error handling (Catch) is the error monad.

### DynamoDB Transaction Monad

```typescript
type DynamoTx<A> = {
  operations: TransactWriteItem[];
  result: (responses: TransactWriteItemsOutput) => A;
};

const dynamoTxMonad: Monad<DynamoTx> = {
  unit: <A>(a: A): DynamoTx<A> => ({
    operations: [],
    result: () => a,
  }),

  bind: <A, B>(ta: DynamoTx<A>, f: (a: A) => DynamoTx<B>): DynamoTx<B> => ({
    operations: [...ta.operations, ...f(ta.result({})).operations],
    result: (resp) => f(ta.result(resp)).result(resp),
  }),
};

// Build transaction monadically
const transferFunds = (from: Account, to: Account, amount: number): DynamoTx<void> =>
  pipe(
    debit(from, amount),
    bind(_ => credit(to, amount)),
    bind(_ => logTransfer(from, to, amount))
  );
```

---

## Kleisli Categories

Every monad $T$ gives rise to a **Kleisli category** where:

- Objects are the same as in the original category
- Morphisms $A \to B$ are functions $A \to T(B)$
- Composition is Kleisli composition: $(g \circ_K f)(a) = \text{bind}(f(a), g)$

**Meaning**: You can pretend effectful operations are pure by working in the Kleisli category.

```typescript
// Kleisli composition for Option
const composeK = <A, B, C>(
  f: (a: A) => Option<B>,
  g: (b: B) => Option<C>
): ((a: A) => Option<C>) =>
  (a: A) => optionMonad.bind(f(a), g);

// Now effectful functions compose like pure ones!
const safeDivThenSqrt = composeK(safeDiv, safeSqrt);
```

---

## Design Patterns with Monads

### Pattern 1: Railway-Oriented Programming

Treat the happy path and error path as two rails:

```typescript
const processOrder = (input: OrderInput): Result<OrderError, Order> =>
  pipe(
    validate(input),           // Might derail to error rail
    bind(checkInventory),      // Might derail
    bind(processPayment),      // Might derail
    bind(createOrder),         // Might derail
    bind(sendConfirmation)     // All succeed or first error
  );
```

### Pattern 2: Effect Injection

Use the Reader monad for dependency injection:

```typescript
type Reader<Env, A> = (env: Env) => A;

const readerMonad = <Env>(): Monad<Reader<Env, *>> => ({
  unit: <A>(a: A): Reader<Env, A> => (_env) => a,
  bind: <A, B>(ra: Reader<Env, A>, f: (a: A) => Reader<Env, B>): Reader<Env, B> =>
    (env) => f(ra(env))(env),
});

// Dependencies are implicit but type-safe
const getUser: Reader<DbContext, User> = (ctx) => ctx.db.findUser(ctx.userId);
const getOrders: Reader<DbContext, Order[]> = (ctx) => ctx.db.findOrders(ctx.userId);
```

### Pattern 3: Effect Accumulation

Use the Writer monad for logging:

```typescript
type Writer<W, A> = { value: A; log: W[] };

const writerMonad = <W>(): Monad<Writer<W, *>> => ({
  unit: <A>(a: A): Writer<W, A> => ({ value: a, log: [] }),
  bind: <A, B>(wa: Writer<W, A>, f: (a: A) => Writer<W, B>): Writer<W, B> => {
    const wb = f(wa.value);
    return { value: wb.value, log: [...wa.log, ...wb.log] };
  },
});
```

---

## The Takeaway

Monads solve the composition problem for effects:

1. **Structure**: Unit + Bind (or Unit + Join)
2. **Laws**: Left identity, Right identity, Associativity
3. **Composition**: Chain effectful operations cleanly
4. **Kleisli**: Work with effects as if they were pure

In architecture:
- Error handling → Result/Either monad
- Async operations → Promise/Task monad
- Transactions → Transaction monad
- Logging → Writer monad
- Configuration → Reader monad

The monad laws ensure your pipelines compose correctly. When composition feels hard, you probably need a monad.

---

*Next in the series: **Comonads: Streaming, Context, and Event-Driven Architecture** — Where we learn the dual of monads and how they model observations and context.*
